#include <bits/stdc++.h>
using namespace std;

class Node
{

public:
    long long val;
    Node *left;
    Node *right;
    long long height;
    long long freq;
    long long sum;
    long long count_less_equal;
    long long count_less;
    long long size;

    Node(long long val)
    {
        this->val = val;
        left = NULL;
        right = NULL;
        height = 1;
        freq = 1;
        sum = val;
        count_less_equal = 1;
        size = 1;
        count_less = 0;
    }
};

class avl_tree
{

public:
    long long getCountLessEqual(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->count_less_equal;
    }

    long long getCountLess(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->count_less;
    }

    long long getBalance(Node *root)
    {
        if (root == NULL)
            return 0;
        return getHeight(root->left) - getHeight(root->right);
    }

    long long getSum(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->sum;
    }

    long long getHeight(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->height;
    }

public:
    long long getSize(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->size;
    }
    Node *LeftRotate(Node *root)
    {
        // Right Right Insertion
        Node *A = root->right;
        Node *C = A->left;

        root->right = C;
        A->left = root;

        // Update height
        root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
        A->height = max(getHeight(A->left), getHeight(A->right)) + 1;

        // Update sum
        root->sum = getSum(root->left) + getSum(root->right) + root->val * root->freq;
        A->sum = getSum(A->left) + getSum(A->right) + A->val * A->freq;
        // Update size
        root->size = getSize(root->left) + getSize(root->right) + root->freq;
        A->size = getSize(A->left) + getSize(A->right) + A->freq;

        // Update count_less and count_less_equal
        root->count_less_equal = getCountLessEqual(root->right) + root->freq;
        root->count_less = getSize(root->left);
        A->count_less_equal = getCountLessEqual(A->right) + A->freq;
        A->count_less = getSize(A->left);

        return A;
    }

    Node *RightRotate(Node *root)
    {
        // Left Left Insertion

        Node *A = root->left;
        Node *C = A->right;

        root->left = C;
        A->right = root;

        // Update height
        root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
        A->height = max(getHeight(A->left), getHeight(A->right)) + 1;

        // Update sum

        root->sum = getSum(root->left) + getSum(root->right) + root->val * root->freq;

        A->sum = getSum(A->left) + getSum(A->right) + A->val * A->freq;
        // cout<<A->val<<" "<<A->sum<<endl;
        // Update size
        root->size = getSize(root->left) + getSize(root->right) + root->freq;
        A->size = getSize(A->left) + getSize(A->right) + A->freq;

        // Update count_less and count_less_equal
        root->count_less_equal = getCountLessEqual(root->left) + root->freq;
        root->count_less = getSize(root->left);
        A->count_less_equal = getCountLessEqual(A->left) + A->freq;
        A->count_less = getSize(A->left);

        return A;
    }

    Node *find(Node *root, long long val)
    {
        if (root == NULL)
            return NULL;
        if (root->val == val)
            return root;
        if (val < root->val)
            return find(root->left, val);
        else
            return find(root->right, val);
    }

    Node *insert(Node *root, long long val)

    {
        if (root == NULL)
        {
            return new Node(val);
        }

        if (val == root->val)
        {
            root->freq++;
            root->sum += val;
            root->count_less_equal++;
            root->size++;
            return root;
        }

        if (val < root->val)
        {
            root->left = insert(root->left, val);
        }
        else
        {

            root->right = insert(root->right, val);
        }

        // Update height
        root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
        // Update sum
        root->sum = getSum(root->left) + getSum(root->right) + root->val * root->freq;

        // Update count_less and count_less_equal
        root->count_less_equal = getCountLessEqual(root->left) + root->freq;
        root->count_less = getSize(root->left);

        // Update size
        root->size = getSize(root->left) + getSize(root->right) + root->freq;

        // Get balance factor
        long long bf = getBalance(root);

        // Left Left Case
        if (bf > 1 && root->left->val >= val)
        {

            // LL Insertion
            // Right Rotate
            return RightRotate(root);
        }

        // Left Right Case
        if (bf > 1 && root->left->val < val)
        {
            // LR Insertion
            // Make it long long o Left Left Case (By Left Rotate) and then Right Rotate
            root->left = LeftRotate(root->left);
            return RightRotate(root);
        }

        // Right Right Case
        if (bf < -1 && root->right->val <= val)
        {

            // RR Insertion
            // Left Rotate
            return LeftRotate(root);
        }

        // Right Left Case

        if (bf < -1 && root->right->val > val)
        {
            // RL Insertion
            // Make it long long o Right Right Case (By Right Rotate) and then Left Rotate
            root->right = RightRotate(root->right);
            return LeftRotate(root);
        }
        return root;
    }

    Node *remove(Node *root, long long val)
    {
        if (root == NULL)
            return root;

        if (val < root->val)
        {
            root->left = remove(root->left, val);
        }
        else if (val > root->val)
        {
            root->right = remove(root->right, val);
        }
        else
        {
            // Value found - this is the node to be deleted
            if (root->freq > 1)
            {
                // If frequency > 1, just decrease frequency
                root->freq--;
                root->sum -= root->val;
                root->size--;
                root->count_less_equal--;
                return root;
            }

            // Node with only one child or no child
            if (root->left == NULL)
            {
                Node *temp = root->right;
                delete root;
                return temp;
            }
            else if (root->right == NULL)
            {
                Node *temp = root->left;
                delete root;
                return temp;
            }

            // Node with two children
            // Find the inorder successor (smallest in the right subtree)
            Node *temp = findMin(root->right);

            // Store successor values before removal
            long long temp_val = temp->val;
            long long temp_freq = temp->freq;

            // Remove the successor from right subtree
            root->right = remove(root->right, temp->val);

            // Replace current node's value with successor's value
            root->val = temp_val;
            root->freq = temp_freq;
        }

        // If the tree had only one node then return
        if (root == NULL)
            return root;

        // Update height
        root->height = max(getHeight(root->left), getHeight(root->right)) + 1;

        // Update size, sum, and counts
        root->size = getSize(root->left) + getSize(root->right) + root->freq;
        root->sum = getSum(root->left) + getSum(root->right) + root->val * root->freq;
        root->count_less = getSize(root->left);
        root->count_less_equal = getCountLessEqual(root->left) + root->freq;

        // Get balance factor
        long long balance = getBalance(root);

        // Left Left Case
        if (balance > 1 && getBalance(root->left) >= 0)
            return RightRotate(root);

        // Left Right Case
        if (balance > 1 && getBalance(root->left) < 0)
        {
            root->left = LeftRotate(root->left);
            return RightRotate(root);
        }

        // Right Right Case
        if (balance < -1 && getBalance(root->right) <= 0)
            return LeftRotate(root);

        // Right Left Case
        if (balance < -1 && getBalance(root->right) > 0)
        {
            root->right = RightRotate(root->right);
            return LeftRotate(root);
        }

        return root;
    }

    Node *findMin(Node *root)
    {
        if (root == NULL)
            return NULL;
        while (root->left != NULL)
            root = root->left;
        return root;
    }

    long long order_of_sum(Node *root, long long val)
    {
        if (root == NULL)
            return 0;
        long long sum = 0;
        if (val > root->val)
        {
            sum = getSum(root->left) + root->freq * root->val + order_of_sum(root->right, val);
        }

        if (val == root->val)
        {
            sum = getSum(root->left);
        }

        if (val < root->val)
        {
            sum = order_of_sum(root->left, val);
        }

        return sum;
    }

    long long order_of_key(Node *root, long long val)
    {
        if (root == NULL)
            return 0;
        long long sum = 0;
        if (val > root->val)
        {
            sum = getSize(root->left) + root->freq + order_of_key(root->right, val);
        }

        if (val == root->val)
        {
            sum = getSize(root->left);
        }

        if (val < root->val)
        {
            sum = order_of_key(root->left, val);
        }

        return sum;
    }

    long long order_of_sum_equal(Node *root, long long val)
    {
        if (root == NULL)
            return 0;
        long long sum = 0;
        if (val > root->val)
        {
            sum = getSum(root->left) + root->freq * root->val + order_of_sum_equal(root->right, val);
        }

        if (val == root->val)
        {
            sum = getSum(root->left) + root->freq * root->val;
        }

        if (val < root->val)
        {
            sum = order_of_sum_equal(root->left, val);
        }

        return sum;
    }

    long long order_of_key_equal(Node *root, long long val)
    {
        if (root == NULL)
            return 0;
        long long sum = 0;
        if (val > root->val)
        {
            sum = getSize(root->left) + root->freq + order_of_key_equal(root->right, val);
        }

        if (val == root->val)
        {
            sum = getSize(root->left) + root->freq;
        }

        if (val < root->val)
        {
            sum = order_of_key_equal(root->left, val);
        }

        return sum;
    }

    Node *find_by_order(Node *root, long long idx)
    {
        if (root == NULL)
            return NULL;

        // Get size of left subtree
        long long leftSize = getSize(root->left);

        // If idx is in the left subtree
        if (idx < leftSize)
        {
            return find_by_order(root->left, idx);
        }
        // If idx is in the current node's range (considering frequency)
        else if (idx < leftSize + root->freq)
        {
            return root;
        }
        // If idx is in the right subtree
        else
        {
            return find_by_order(root->right, idx - leftSize - root->freq);
        }
    }

    void inorder(Node *root)
    {
        if (root == NULL)
            return;
        inorder(root->left);
        cout << root->val << " ";
        inorder(root->right);
    }
};

long long dp[100005][17];
unordered_map<long long, long long> op;

long long func(long long idx, long long k, long long x)
{

    if (idx >= op.size())
    {
        if (k == 0)
        {
            return 0;
        }
        return 1e17;
    }

    if (dp[idx][k] != -1)
    {
        return dp[idx][k];
    }
    long long ans = 1e17;
    if (k > 0)
    {
        ans = min(ans, op[idx] + func(idx + x, k - 1, x));
    }
    ans = min(ans, func(idx + 1, k, x));

    return dp[idx][k] = ans;
}

class Solution
{
public:
    long long minOperations(vector<int> &v, long long x, long long k)
    {

        avl_tree *avl = new avl_tree();
        Node *root = NULL;
        op.clear();
        for (long long i = 0; i < v.size(); i++)
        {
            op[i] = 1e17;
        }

        for (long long i = 0; i <= v.size() + 2; i++)
        {
            for (long long j = 0; j <= k + 1; j++)
            {
                dp[i][j] = -1;
            }
        }

        for (long long i = 0; i < x - 1; i++)
        {
            root = avl->insert(root, v[i]);
        }
        for (long long i = x - 1; i < v.size(); i++)
        {
            root = avl->insert(root, v[i]);

            long long sz = avl->getSize(root);
            // cout<<i<<" "<<avl->getSum(root)<<" "<<root->val<<endl;
            if (x % 2)
            {
                // Odd
                long long median = avl->find_by_order(root, sz / 2)->val;
                long long total_sum = avl->getSum(root);
                long long left_sum = avl->order_of_sum_equal(root, median);
                long long larger_sum = total_sum - left_sum;
                long long cnt1 = avl->order_of_key_equal(root, median);
                long long cnt2 = sz - cnt1;
                op[i - (x - 1)] = abs(left_sum - cnt1 * median) + abs(larger_sum - cnt2 * median);
                // cout<<i<<" "<<median<<" "<<op[i - (x - 1)]<<" "<<" "<<total_sum<<" "<<left_sum<<" "<<larger_sum<<" "<<cnt1<<" "<<cnt2<<endl;
            }
            else
            {

                vector<long long> median;
                median.push_back(avl->find_by_order(root, sz / 2)->val);
                median.push_back(avl->find_by_order(root, sz / 2 - 1)->val);

                for (long long j = 0; j < median.size(); j++)
                {
                    long long total_sum = avl->getSum(root);
                    long long left_sum = avl->order_of_sum_equal(root, median[j]);
                    long long larger_sum = total_sum - left_sum;
                    long long cnt1 = avl->order_of_key_equal(root, median[j]);
                    long long cnt2 = sz - cnt1;
                    op[i - (x - 1)] = min(op[i - (x - 1)], abs(left_sum - cnt1 * median[j]) + abs(larger_sum - cnt2 * median[j]));
                }
            }

            root = avl->remove(root, v[i - (x - 1)]);
        }

        return func(0, k, x);
    }
};

int main()
{

    Solution *sol = new Solution();
    vector<int> v = {916275, 599566, -341498, -927813, -906968, -136945, -622756, 823835, -964043, -596365, 120508, 253845, 17642, -471889, -951282, 514428, -708406, 148212, -640214, -570717, 654666, -281680, 6587, 369408, -972786, -50671, -586246, -315332, -579434, 629214, 20559, -317445, -814220, 921584, -635500, -996919, 586515, -513632, -4025, -831235, -44073, 421273, -586527, 32216, 308110, 129933, 628828, -946770, 623407, 314837, 961566, 730405, -14880, -503916, 925344, 860742, 591376, 953911, -923366, -4788, -178561, -433750, 960688, -223730, -123325, 726164, -646634, 716349, 122901, -105932, -88077, 239633, -792426, -593725, 413600, -659033, -769065, 16152, -476085, 944813, -199529, -243064, -848937, -700216, 833444, -473693, -324620, -498040, 98394, 364879, -834164, -721518, 560464, -990841, 10255, 613087, 821331, 170399, -985579, -194386, -604101, -440363, -76449, -497864, -661284, -205536, -535559, 978097, -928538, -235978, -157668, 587443, 487302, -66929, 55122, -580699, 462539, -293279, -11983, -276452, -655096, -94756, 199567, 766241, -603486, 545339, -77264, -60576, -763188, -794814, -783031, 506986, 892652, 8837, -382522, -937581, 14612, 415035, 334562, -516300, -97617, -293283, 83927, -240477, -442557, -258742, -417323, -870190, -873993, -965232, 708307, 450842, -203548, 553426, -91732, 68986, 207401, -399942, 296430, -150071, 671987, -308623, 3953, 60672, -918292, 216444, -846383, 510561, 89066, -795354, -347213, -532314, 119491, 605913, -955121, -360971, -602148, -592909, -841137, 668195, -505996, 720244, 928151, -951235, 287601, -395113, -414962, -200351, -13042, 225191, -332481, -308765, 826985, -893355, 482937, -964363, 279974, 672, -998647, 224990, -6736, 697875, 730528, -342388, -444518, -844494, -595295, 130384, 502711, -48321, 453973, 901712, 734722, 943060, -727894, -257007, -621499, -498110, 880922, -791038, 480937, -5102, -109534, 414114, 316144, 320383, -33537, 213053, -940169, 999329, 859893, 118162, -95949, 319190, 841021, 800489, -603566, -944240, -80787, 340659, 747350, -506402, -939664, -154679, 749870, -919113, 589767, 642546, -529493, -479153, 26317, -130694, 879609, -837148, 243455, 300022, -384690, -895161, -716894, -75111, 425214, -716241, 447383, 37060, -493524, 60640, -206844, 403284, -925384, 290004, 935743, -384001, 484790, -77029, -451378, 559996, -623538, 230073, -952235, -268657, -221142, 623024, 413906, -158155, -424048, 648873, -719490, 597867, 220951, -583131, 110520, -352447, -609421, -835090, -486806, 381270, -541582, 424938, 363921, 634332, -431120, -789390, -110774, -687206, -576011, -720625, -886288, 383214, -984377, -967908, -598264, 992203, 533981, 247420, 530912, 67555, 893753, -708498, -433352, 703956, 687566, 318861, 724279, -609265, 468645, 698017, -263176, 173818, 635808, -905964, -865321, 676432, -208727, -893921, -853268, -259475, 596926, 798496, 239351, -475509, -453179, 428230, 416491, -550612, -27654, 378472, -3982, -379909, -114303, -682785, -89976, -192270, 182529, -451128, -516089, -260061, 491077, 649155, -822645, 933213, 671748, -686184, -968269, -604663, 180927, -190858, -663308, 85657, -256484, -769694, -189295, -455125, -398057, 476259, -484001, 422418, -341948, 745122, 723830, -991992, -239825, -76645, -736352, 363585, -640607, -848505, 371905, 756420, -705393, -285618, -94512, -618467, 32916, -712717, -671181, -472010, 662238, -215334, 903981, -335395, -315825, -712621, -166430, -853278, -604921, 975566, -617458, 346437, 551068, -845529, 1138, -884212, 532537, 694832, 889060, -711676, 335242, 318701, 632065, -960907, 66929, -911940, 741441, -627961, -394323, -272477, -408895, 959755, -196460, 751588, -247573, 969626, 114284, -674656, 926265, 920132, 398806, -768596, 493027, -249591, -514787, -239927, -570891, -937063, 848727, -490063, -135353, 202918, 756899, -942179, -954518, -48929, 971623, 902, -227477, -279047, -973825, 408527, -977918, -977831, 86705, -838001, -892053, 526627, -772801, -828446, -795704, -575767, 852646, -390968, 887972, 739059, 121614, 120494, -839411, 505378, -385912, -88877, -742704, -960325, 158035, 532221, 341653, 598210, 430567, 542626, -844482, 398881, 617894, 473725, -609386, -196163, 14256, 864787, 150322, -746218, -740912, -226889, 685608, 325047, 213658, -701703, 803417, -360149, -514164, -880642, -587887, -905479, -549021, -518836, 399835, 554748, -888900, 577057, -385714, 40654, 390162, 992816, -685919, -533534, -812315, -670771, -811176, -830715, 40676, -112544, -883677, -589174, -319290, -884569, 736731, 514805, 984636, 279848, 176130, 781660, 639778, -929360, 447649, 86166, 124071, -618966, -666336, -737491, 308804, 775125, 681714, 210395, -301995, -885353, 675785, 845806, -154798, 297296, -890951, -583222, -839431, 84395, 605703, 311425, -316248, -629832, 77219, -495243, 825800, -216265, -52510, 306563, 401633, -404530, -17527, -498224, -709749, 332468, 78301, -848106, 988702, 117929, 868268, 707413, 132353, 659265, 508650, 536968, -420940, -295542, 2641, -309738, 381385, -506115, -514795, -589997, -659800, -419880, 234058, -260269, -548320, 807940, -803979, 999938, 621002, -229348, -487109, 920132, 701921, -390431, 648300, -802723, -974270, 597924, 799177, -230016, 397715, 860310, -170207, -446996, -271166, -390699, 267918, 933928, 40449, 540180, -499111, 778635, 659990, 938354, 327411, -876062, -641625, -318632, -386203, 399138, 856248, -86329, -251130, -423190, 851352, 453448, 774550, 100720, 333232, -55291, 766914, -11459, -369302, 693396, 170410, -414447, -588714, 64864, -801833, 3628, 750053, 630608, -285066, -277293, -864175, -819156, 525507, 898787, -10440, 267141, -551657, 978074, -87422, 613318, -511925, -626210, 275547, 604363, -700878, 734353, -286788, -164918, 317059, 313644, 787272, -964080, -888989, 59199, 350179, 8919, -498204, -400642, -871427, 139438, -756829, 807816, 332571, 51199, -978588, 467600, 830156, -893450, -582184, 701575, -215759, 14317, 259747, 42058, 738874, -924842, 431263, -854831, 49635, 771821, 876488, 622717, 325001, 494102, -428124, 183759, 18604, 740209, 328891, 377096, 622114, 518131, 746651, -375794, 632619, -524778, -306255, -552701, -544098, -675130, 856561, -998048, 181627, 930709, -129343, 383798, 299466, -633970, 396608, -948772, 615683, -81059, -653854, 956979, 63051, 471617};

    int x = 727;
    int k = 1;
    cout << sol->minOperations(v, x, k) << endl;
}

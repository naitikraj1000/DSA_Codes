#include <bits/stdc++.h>
using namespace std;

class Node
{

public:
    int val;
    Node *left;
    Node *right;
    int height;
    int freq;
    int sum;
    int count_less_equal;
    int count_less;
    int size;

    Node(int val)
    {
        this->val = val;
        left = NULL;
        right = NULL;
        height = 1;
        freq = 1;
        sum = val;
        count_less_equal = 1;
        size = 1;
        count_less = 0;
    }
};

class avl_tree
{

public:
    int getCountLessEqual(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->count_less_equal;
    }

    int getCountLess(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->count_less;
    }

    int getBalance(Node *root)
    {
        if (root == NULL)
            return 0;
        return getHeight(root->left) - getHeight(root->right);
    }

    int getSum(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->sum;
    }

    int getHeight(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->height;
    }

public:
    int getSize(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->size;
    }
    Node *LeftRotate(Node *root)
    {
        // Right Right Insertion
        Node *A = root->right;
        Node *C = A->left;

        root->right = C;
        A->left = root;

        // Update height
        root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
        A->height = max(getHeight(A->left), getHeight(A->right)) + 1;

        // Update sum
        root->sum = getSum(root->left) + getSum(root->right) + root->val*root->freq;
        A->sum = getSum(A->left) + getSum(A->right) + A->val;
        // Update size
        root->size = getSize(root->left) + getSize(root->right) + root->freq;
        A->size = getSize(A->left) + getSize(A->right) + A->freq;

        // Update count_less and count_less_equal
        root->count_less_equal = getCountLessEqual(root->right) + root->freq;
        root->count_less = getSize(root->left);
        A->count_less_equal = getCountLessEqual(A->right) + A->freq;
        A->count_less = getSize(A->left);

        return A;
    }

    Node *RightRotate(Node *root)
    {
        // Left Left Insertion

        Node *A = root->left;
        Node *C = A->right;

        root->left = C;
        A->right = root;

        // Update height
        root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
        A->height = max(getHeight(A->left), getHeight(A->right)) + 1;

        // Update sum

        root->sum = getSum(root->left) + getSum(root->right) + root->val*root->freq;
        A->sum = getSum(A->left) + getSum(A->right) + A->val;

        // Update size
        root->size = getSize(root->left) + getSize(root->right) + root->freq;
        A->size = getSize(A->left) + getSize(A->right) + A->freq;

        // Update count_less and count_less_equal
        root->count_less_equal = getCountLessEqual(root->left) + root->freq;
        root->count_less = getSize(root->left);
        A->count_less_equal = getCountLessEqual(A->left) + A->freq;
        A->count_less = getSize(A->left);

        return A;
    }

    Node *find(Node *root, int val)
    {
        if (root == NULL)
            return NULL;
        if (root->val == val)
            return root;
        if (val < root->val)
            return find(root->left, val);
        else
            return find(root->right, val);
    }

    Node *insert(Node *root, int val)

    {
        if (root == NULL)
        {
            return new Node(val);
        }

        if (val == root->val)
        {
            root->freq++;
            root->sum += val;
            root->count_less_equal++;
            root->size++;
            return root;
        }

        if (val < root->val)
        {
            root->left = insert(root->left, val);
        }
        else
        {
           
            root->right = insert(root->right, val);
        }

    

        // Update height
        root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
        // Update sum
        root->sum = getSum(root->left) + getSum(root->right) + root->val* root->freq;
       
        // Update count_less and count_less_equal
        root->count_less_equal = getCountLessEqual(root->left) + root->freq;
        root->count_less = getSize(root->left);

        // Update size
        root->size = getSize(root->left) + getSize(root->right) + root->freq;

        // Get balance factor
        int bf = getBalance(root);
        
       
        // Left Left Case
        if (bf > 1 && root->left->val >= val)
        {
            // LL Insertion
            // Right Rotate
            return RightRotate(root);
        }

        // Left Right Case
        if (bf > 1 && root->left->val < val)
        {
            // LR Insertion
            // Make it into Left Left Case (By Left Rotate) and then Right Rotate
            root->left = LeftRotate(root->left);
            return RightRotate(root);
        }

        // Right Right Case
        if (bf < -1 && root->right->val <= val)
        {
            
            // RR Insertion
            // Left Rotate
            return LeftRotate(root);
        }

        // Right Left Case

        if (bf < -1 && root->right->val > val)
        {
            // RL Insertion
            // Make it into Right Right Case (By Right Rotate) and then Left Rotate
            root->right = RightRotate(root->right);
            return LeftRotate(root);
        }
        return root;
    }

    Node *remove(Node *root, int val) {
        if (root == NULL) return root;
    
        if (val < root->val) {
            root->left = remove(root->left, val);
        } else if (val > root->val) {
            root->right = remove(root->right, val);
        } else {
            // Value found - this is the node to be deleted
            if (root->freq > 1) {
                root->freq--;
                root->sum -= root->val;
                root->size--;
                return root;
            }
    
            // Node with only one child or no child
            if (root->left == NULL) {
                Node *temp = root->right;
                delete root;
                return temp;
            } else if (root->right == NULL) {
                Node *temp = root->left;
                delete root;
                return temp;
            }
    
            // Node with two children
            Node *temp = findMin(root->right);
            // Store all necessary values before deletion
            int temp_val = temp->val;
            int temp_freq = temp->freq;
            // Remove the successor (will be handled recursively)
            root->right = remove(root->right, temp->val);
            // Update current node's values
            root->val = temp_val;
            root->freq = temp_freq;
        }
    
        // If the tree had only one node then return
        if (root == NULL) return root;
    
        // Update height, size, sum, and counts
        root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
        root->size = getSize(root->left) + getSize(root->right) + root->freq;
        root->sum = getSum(root->left) + getSum(root->right) + root->val * root->freq;
        root->count_less = getSize(root->left);
        root->count_less_equal = getCountLessEqual(root->left) + root->freq;
    
        // Rebalance the tree
        int balance = getBalance(root);
    
        // Left Left Case
        if (balance > 1 && getBalance(root->left) >= 0)
            return RightRotate(root);
    
        // Left Right Case
        if (balance > 1 && getBalance(root->left) < 0) {
            root->left = LeftRotate(root->left);
            return RightRotate(root);
        }
    
        // Right Right Case
        if (balance < -1 && getBalance(root->right) <= 0)
            return LeftRotate(root);
    
        // Right Left Case
        if (balance < -1 && getBalance(root->right) > 0) {
            root->right = RightRotate(root->right);
            return LeftRotate(root);
        }
    
        return root;
    }


    Node *findMin(Node *root)
    {
        if (root == NULL)
            return NULL;
        while (root->left != NULL)
            root = root->left;
        return root;
    }

    long long order_of_sum(Node *root, int val)
    {
        if (root == NULL)
            return 0;
        long long sum = 0;
        if (val > root->val)
        {
            sum = getSum(root->left) + root->freq * root->val + order_of_sum(root->right, val);
        }

        if (val == root->val)
        {
            sum = getSum(root->left);
        }

        if (val < root->val)
        {
            sum = order_of_sum(root->left, val);
        }

        return sum;
    }

    long long order_of_key(Node *root, int val)
    {
        if (root == NULL)
            return 0;
        long long sum = 0;
        if (val > root->val)
        {
            sum = getSize(root->left) + root->freq + order_of_key(root->right, val);
        }

        if (val == root->val)
        {
            sum = getSize(root->left);
        }

        if (val < root->val)
        {
            sum = order_of_key(root->left, val);
        }

        return sum;
    }

    long long order_of_sum_equal(Node *root, int val)
    {
        if (root == NULL)
            return 0;
        long long sum = 0;
        if (val > root->val)
        {
            sum = getSum(root->left) + root->freq * root->val + order_of_sum_equal(root->right, val);
        }

        if (val == root->val)
        {
            sum = getSum(root->left) + root->freq * root->val;
        }

        if (val < root->val)
        {
            sum = order_of_sum_equal(root->left, val);
        }

        return sum;
    }

    long long order_of_key_equal(Node *root, int val)
    {
        if (root == NULL)
            return 0;
        long long sum = 0;
        if (val > root->val)
        {
            sum = getSize(root->left) + root->freq + order_of_key_equal(root->right, val);
        }

        if (val == root->val)
        {
            sum = getSize(root->left) + root->freq;
        }

        if (val < root->val)
        {
            sum = order_of_key_equal(root->left, val);
        }

        return sum;
    }

    Node *find_by_order(Node *root, int idx)
    {
        if (root == NULL)
            return NULL;

        // Get size of left subtree
        int leftSize = getSize(root->left);

        // If idx is in the left subtree
        if (idx < leftSize)
        {
            return find_by_order(root->left, idx);
        }
        // If idx is in the current node's range (considering frequency)
        else if (idx < leftSize + root->freq)
        {
            return root;
        }
        // If idx is in the right subtree
        else
        {
            return find_by_order(root->right, idx - leftSize - root->freq);
        }
    }

    void inorder(Node *root)
    {
        if (root == NULL)
            return;
        inorder(root->left);
        cout << root->val << " ";
        inorder(root->right);
    }
};

long long dp[100005][16];
unordered_map<int, int> op;

long long func(int idx, int k, int x)
{
    if (idx == op.size())
    {
        if (k == 0)
        {
            return 0;
        }
        return INT_MAX;
    }

    if (dp[idx][k] != -1)
    {
        return dp[idx][k];
    }
    long long ans = INT_MAX;
    if (k > 0)
    {
        ans = min(ans, op[idx] + func(idx + x, k - 1, x));
    }
    ans = min(ans, func(idx + 1, k, x));
    return dp[idx][k] = ans;
}

class Solution
{
public:
    long long minOperations(vector<int> &v, int x, int k)
    {

        avl_tree *avl = new avl_tree();
        Node *root = NULL;
        op.clear();
        for (int i = 0; i < v.size(); i++)
        {
            op[i] = INT_MAX;
        }

        for (int i = 0; i <= v.size(); i++)
        {
            for (int j = 0; j <= k; j++)
            {
                dp[i][j] = -1;
            }
        }

        for (int i = 0; i < x - 1; i++)
        {
            root = avl->insert(root, v[i]);
          
        }
        for (int i = x - 1; i < v.size(); i++)
        {
            root = avl->insert(root, v[i]);
         
            int sz = avl->getSize(root);
            // cout<<i<<" "<<avl->getSum(root)<<" "<<root->val<<endl;
            if (x % 2)
            {
                // Odd
                int median = avl->find_by_order(root, sz / 2)->val;
                int total_sum = avl->getSum(root);
                int left_sum = avl->order_of_sum_equal(root, median);
                int larger_sum = total_sum - left_sum;
                int cnt1 = avl->order_of_key_equal(root, median);
                int cnt2 = sz - cnt1;
                op[i - (x - 1)] = abs(left_sum - cnt1 * median) + abs(larger_sum - cnt2 * median);
                cout<<i<<" "<<median<<" "<<op[i - (x - 1)]<<" "<<sz<<endl;
            }
            else
            {
                
                vector<int> median;
                median.push_back(avl->find_by_order(root, sz / 2)->val);
                median.push_back(avl->find_by_order(root, sz / 2 - 1)->val);
               
                for (int j = 0; j < median.size(); j++)
                {
                    int total_sum = avl->getSum(root);
                    int left_sum = avl->order_of_sum_equal(root, median[j]);
                    int larger_sum = total_sum - left_sum;
                    int cnt1 = avl->order_of_key_equal(root, median[j]);
                    int cnt2 = sz - cnt1;
                    op[i - (x - 1)] = min(op[i - (x - 1)], abs(left_sum - cnt1 * median[j]) + abs(larger_sum - cnt2 * median[j]));
                    // cout<<i<<" "<<median[j]<<" "<<total_sum<<" "<<left_sum<<" "<<larger_sum<<" "<<cnt1<<" "<<cnt2<<endl;
                }
            }
            // cout<<i<<" "<<avl->getSize(root)<<" "<<v[i-(x-1)]<<endl;
            root = avl->remove(root, v[i - (x - 1)]);
            // cout<<i<<" "<<avl->getSize(root)<<endl;
            
        }

        return func(0, k, x);
    }
};

int main()
{
    vector<int> v = {17,-1};
    int x = 2, k = 1;
    Solution s;
    cout << s.minOperations(v, x, k) << endl;
}

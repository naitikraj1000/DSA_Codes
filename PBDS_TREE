#include <bits/stdc++.h>
using namespace std;

class Node
{

public:
    long long val;
    Node *left;
    Node *right;
    long long height;
    long long freq;
    long long sum;
    long long count_less_equal;
    long long count_less;
    long long size;

    Node(long long val)
    {
        this->val = val;
        left = NULL;
        right = NULL;
        height = 1;
        freq = 1;
        sum = val;
        count_less_equal = 1;
        size = 1;
        count_less = 0;
    }
};

class avl_tree
{

public:
    long long getCountLessEqual(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->count_less_equal;
    }

    long long getCountLess(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->count_less;
    }

    long long getBalance(Node *root)
    {
        if (root == NULL)
            return 0;
        return getHeight(root->left) - getHeight(root->right);
    }

    long long getSum(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->sum;
    }

    long long getHeight(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->height;
    }

    public:
    long long getSize(Node *root)
    {
        if (root == NULL)
            return 0;
        return root->size;
    }
    Node *LeftRotate(Node *root)
    {
        // Right Right Insertion
        Node *A = root->right;
        Node *C = A->left;

        root->right = C;
        A->left = root;

        // Update height
        root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
        A->height = max(getHeight(A->left), getHeight(A->right)) + 1;

        // Update sum
        root->sum = getSum(root->left) + getSum(root->right) + root->val * root->freq;
        A->sum = getSum(A->left) + getSum(A->right) + A->val * A->freq;
        // Update size
        root->size = getSize(root->left) + getSize(root->right) + root->freq;
        A->size = getSize(A->left) + getSize(A->right) + A->freq;

        // Update count_less and count_less_equal
        root->count_less_equal = getCountLessEqual(root->right) + root->freq;
        root->count_less = getSize(root->left);
        A->count_less_equal = getCountLessEqual(A->right) + A->freq;
        A->count_less = getSize(A->left);

        return A;
    }

    Node *RightRotate(Node *root)
    {
        // Left Left Insertion

        Node *A = root->left;
        Node *C = A->right;

        root->left = C;
        A->right = root;

        // Update height
        root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
        A->height = max(getHeight(A->left), getHeight(A->right)) + 1;

        // Update sum

        root->sum = getSum(root->left) + getSum(root->right) + root->val * root->freq;

        A->sum = getSum(A->left) + getSum(A->right) + A->val * A->freq;
        root->size = getSize(root->left) + getSize(root->right) + root->freq;
        A->size = getSize(A->left) + getSize(A->right) + A->freq;

        // Update count_less and count_less_equal
        root->count_less_equal = getCountLessEqual(root->left) + root->freq;
        root->count_less = getSize(root->left);
        A->count_less_equal = getCountLessEqual(A->left) + A->freq;
        A->count_less = getSize(A->left);

        return A;
    }

    Node *find(Node *root, long long val)
    {
        if (root == NULL)
            return NULL;
        if (root->val == val)
            return root;
        if (val < root->val)
            return find(root->left, val);
        else
            return find(root->right, val);
    }

    Node *insert(Node *root, long long val)

    {
        if (root == NULL)
        {
            return new Node(val);
        }

        if (val == root->val)
        {
            root->freq++;
            root->sum += val;
            root->count_less_equal++;
            root->size++;
            return root;
        }

        if (val < root->val)
        {
            root->left = insert(root->left, val);
        }
        else
        {

            root->right = insert(root->right, val);
        }

        // Update height
        root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
        // Update sum
        root->sum = getSum(root->left) + getSum(root->right) + root->val * root->freq;

        // Update count_less and count_less_equal
        root->count_less_equal = getCountLessEqual(root->left) + root->freq;
        root->count_less = getSize(root->left);

        // Update size
        root->size = getSize(root->left) + getSize(root->right) + root->freq;

        // Get balance factor
        long long bf = getBalance(root);

        // Left Left Case
        if (bf > 1 && root->left->val >= val)
        {

            // LL Insertion
            // Right Rotate
            return RightRotate(root);
        }

        // Left Right Case
        if (bf > 1 && root->left->val < val)
        {
            // LR Insertion
            // Make it long long o Left Left Case (By Left Rotate) and then Right Rotate
            root->left = LeftRotate(root->left);
            return RightRotate(root);
        }

        // Right Right Case
        if (bf < -1 && root->right->val <= val)
        {

            // RR Insertion
            // Left Rotate
            return LeftRotate(root);
        }

        // Right Left Case

        if (bf < -1 && root->right->val > val)
        {
            // RL Insertion
            // Make it long long o Right Right Case (By Right Rotate) and then Left Rotate
            root->right = RightRotate(root->right);
            return LeftRotate(root);
        }
        return root;
    }

    Node *remove(Node *root, long long val)
    {
        if (root == NULL)
            return root;

        if (val < root->val)
        {
            root->left = remove(root->left, val);
        }
        else if (val > root->val)
        {
            root->right = remove(root->right, val);
        }
        else
        {
            // Value found - this is the node to be deleted
            if (root->freq > 1)
            {
                // If frequency > 1, just decrease frequency
                root->freq--;
                root->sum -= root->val;
                root->size--;
                root->count_less_equal--;
                return root;
            }

            // Node with only one child or no child
            if (root->left == NULL)
            {
                Node *temp = root->right;
                delete root;
                return temp;
            }
            else if (root->right == NULL)
            {
                Node *temp = root->left;
                delete root;
                return temp;
            }

            // Node with two children
            // Find the inorder successor (smallest in the right subtree)
            Node *temp = findMin(root->right);

            root->val = temp->val;
            root->freq = temp->freq;
            // Remove the successor from right subtree
            root->right = remove(root->right, temp->val);


        }

        // If the tree had only one node then return
        if (root == NULL)
            return root;

        // Update height
        root->height = max(getHeight(root->left), getHeight(root->right)) + 1;

        // Update size, sum, and counts
        root->size = getSize(root->left) + getSize(root->right) + root->freq;
        root->sum = getSum(root->left) + getSum(root->right) + root->val * root->freq;
        root->count_less = getSize(root->left);
        root->count_less_equal = getCountLessEqual(root->left) + root->freq;

        // Get balance factor
        long long balance = getBalance(root);

        // Left Left Case
        if (balance > 1 && getBalance(root->left) >= 0)
            return RightRotate(root);

        // Left Right Case
        if (balance > 1 && getBalance(root->left) < 0)
        {
            root->left = LeftRotate(root->left);
            return RightRotate(root);
        }

        // Right Right Case
        if (balance < -1 && getBalance(root->right) <= 0)
            return LeftRotate(root);

        // Right Left Case
        if (balance < -1 && getBalance(root->right) > 0)
        {
            root->right = RightRotate(root->right);
            return LeftRotate(root);
        }

        return root;
    }

    Node *findMin(Node *root)
    {
        if (root == NULL)
            return NULL;
        while (root->left != NULL)
            root = root->left;
        return root;
    }

    long long order_of_sum(Node *root, long long val)
    {
        if (root == NULL)
            return 0;
        long long sum = 0;
        if (val > root->val)
        {
            sum = getSum(root->left) + root->freq * root->val + order_of_sum(root->right, val);
        }

        if (val == root->val)
        {
            sum = getSum(root->left);
        }

        if (val < root->val)
        {
            sum = order_of_sum(root->left, val);
        }

        return sum;
    }

    long long order_of_key(Node *root, long long val)
    {
        if (root == NULL)
            return 0;
        long long sum = 0;
        if (val > root->val)
        {
            sum = getSize(root->left) + root->freq + order_of_key(root->right, val);
        }

        if (val == root->val)
        {
            sum = getSize(root->left);
        }

        if (val < root->val)
        {
            sum = order_of_key(root->left, val);
        }

        return sum;
    }

    long long order_of_sum_equal(Node *root, long long val)
    {
        if (root == NULL)
            return 0;
        long long sum = 0;
        if (val > root->val)
        {
            sum = getSum(root->left) + root->freq * root->val + order_of_sum_equal(root->right, val);
        }

        if (val == root->val)
        {
            sum = getSum(root->left) + root->freq * root->val;
        }

        if (val < root->val)
        {
            sum = order_of_sum_equal(root->left, val);
        }

        return sum;
    }

    long long order_of_key_equal(Node *root, long long val)
    {
        if (root == NULL)
            return 0;
        long long sum = 0;
        if (val > root->val)
        {
            sum = getSize(root->left) + root->freq + order_of_key_equal(root->right, val);
        }

        if (val == root->val)
        {
            sum = getSize(root->left) + root->freq;
        }

        if (val < root->val)
        {
            sum = order_of_key_equal(root->left, val);
        }

        return sum;
    }

    Node *find_by_order(Node *root, long long idx)
    {
        if (root == NULL)
            return NULL;

        // Get size of left subtree
        long long leftSize = getSize(root->left);

        // If idx is in the left subtree
        if (idx < leftSize)
        {
            return find_by_order(root->left, idx);
        }
        // If idx is in the current node's range (considering frequency)
        else if (idx < leftSize + root->freq)
        {
            return root;
        }
        // If idx is in the right subtree
        else
        {
            return find_by_order(root->right, idx - leftSize - root->freq);
        }
    }

    void inorder(Node *root)
    {
        if (root == NULL)
            return;
        inorder(root->left);
        cout << root->val << " ";
        inorder(root->right);
    }
};
